// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `syros.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct LockRequest {
    // message fields
    pub key: ::std::string::String,
    pub owner: ::std::string::String,
    pub ttl_seconds: u64,
    pub metadata: ::std::string::String,
    pub wait_timeout_seconds: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LockRequest {
    fn default() -> &'a LockRequest {
        <LockRequest as ::protobuf::Message>::default_instance()
    }
}

impl LockRequest {
    pub fn new() -> LockRequest {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string owner = 2;


    pub fn get_owner(&self) -> &str {
        &self.owner
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        &mut self.owner
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.owner, ::std::string::String::new())
    }

    // uint64 ttl_seconds = 3;


    pub fn get_ttl_seconds(&self) -> u64 {
        self.ttl_seconds
    }
    pub fn clear_ttl_seconds(&mut self) {
        self.ttl_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_ttl_seconds(&mut self, v: u64) {
        self.ttl_seconds = v;
    }

    // string metadata = 4;


    pub fn get_metadata(&self) -> &str {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metadata, ::std::string::String::new())
    }

    // uint64 wait_timeout_seconds = 5;


    pub fn get_wait_timeout_seconds(&self) -> u64 {
        self.wait_timeout_seconds
    }
    pub fn clear_wait_timeout_seconds(&mut self) {
        self.wait_timeout_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_wait_timeout_seconds(&mut self, v: u64) {
        self.wait_timeout_seconds = v;
    }
}

impl ::protobuf::Message for LockRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.owner)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ttl_seconds = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.metadata)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.wait_timeout_seconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.owner);
        }
        if self.ttl_seconds != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ttl_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.metadata);
        }
        if self.wait_timeout_seconds != 0 {
            my_size += ::protobuf::rt::value_size(5, self.wait_timeout_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.owner.is_empty() {
            os.write_string(2, &self.owner)?;
        }
        if self.ttl_seconds != 0 {
            os.write_uint64(3, self.ttl_seconds)?;
        }
        if !self.metadata.is_empty() {
            os.write_string(4, &self.metadata)?;
        }
        if self.wait_timeout_seconds != 0 {
            os.write_uint64(5, self.wait_timeout_seconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LockRequest {
        LockRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &LockRequest| { &m.key },
                |m: &mut LockRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "owner",
                |m: &LockRequest| { &m.owner },
                |m: &mut LockRequest| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ttl_seconds",
                |m: &LockRequest| { &m.ttl_seconds },
                |m: &mut LockRequest| { &mut m.ttl_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &LockRequest| { &m.metadata },
                |m: &mut LockRequest| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "wait_timeout_seconds",
                |m: &LockRequest| { &m.wait_timeout_seconds },
                |m: &mut LockRequest| { &mut m.wait_timeout_seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LockRequest>(
                "LockRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LockRequest {
        static instance: ::protobuf::rt::LazyV2<LockRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LockRequest::new)
    }
}

impl ::protobuf::Clear for LockRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.owner.clear();
        self.ttl_seconds = 0;
        self.metadata.clear();
        self.wait_timeout_seconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LockResponse {
    // message fields
    pub lock_id: ::std::string::String,
    pub success: bool,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LockResponse {
    fn default() -> &'a LockResponse {
        <LockResponse as ::protobuf::Message>::default_instance()
    }
}

impl LockResponse {
    pub fn new() -> LockResponse {
        ::std::default::Default::default()
    }

    // string lock_id = 1;


    pub fn get_lock_id(&self) -> &str {
        &self.lock_id
    }
    pub fn clear_lock_id(&mut self) {
        self.lock_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_lock_id(&mut self, v: ::std::string::String) {
        self.lock_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lock_id(&mut self) -> &mut ::std::string::String {
        &mut self.lock_id
    }

    // Take field
    pub fn take_lock_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lock_id, ::std::string::String::new())
    }

    // bool success = 2;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LockResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lock_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.lock_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.lock_id);
        }
        if self.success != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.lock_id.is_empty() {
            os.write_string(1, &self.lock_id)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LockResponse {
        LockResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lock_id",
                |m: &LockResponse| { &m.lock_id },
                |m: &mut LockResponse| { &mut m.lock_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &LockResponse| { &m.success },
                |m: &mut LockResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &LockResponse| { &m.message },
                |m: &mut LockResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LockResponse>(
                "LockResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LockResponse {
        static instance: ::protobuf::rt::LazyV2<LockResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LockResponse::new)
    }
}

impl ::protobuf::Clear for LockResponse {
    fn clear(&mut self) {
        self.lock_id.clear();
        self.success = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReleaseLockRequest {
    // message fields
    pub key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReleaseLockRequest {
    fn default() -> &'a ReleaseLockRequest {
        <ReleaseLockRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReleaseLockRequest {
    pub fn new() -> ReleaseLockRequest {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReleaseLockRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReleaseLockRequest {
        ReleaseLockRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &ReleaseLockRequest| { &m.key },
                |m: &mut ReleaseLockRequest| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReleaseLockRequest>(
                "ReleaseLockRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReleaseLockRequest {
        static instance: ::protobuf::rt::LazyV2<ReleaseLockRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReleaseLockRequest::new)
    }
}

impl ::protobuf::Clear for ReleaseLockRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReleaseLockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReleaseLockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReleaseLockResponse {
    // message fields
    pub success: bool,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReleaseLockResponse {
    fn default() -> &'a ReleaseLockResponse {
        <ReleaseLockResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReleaseLockResponse {
    pub fn new() -> ReleaseLockResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReleaseLockResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReleaseLockResponse {
        ReleaseLockResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &ReleaseLockResponse| { &m.success },
                |m: &mut ReleaseLockResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &ReleaseLockResponse| { &m.message },
                |m: &mut ReleaseLockResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReleaseLockResponse>(
                "ReleaseLockResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReleaseLockResponse {
        static instance: ::protobuf::rt::LazyV2<ReleaseLockResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReleaseLockResponse::new)
    }
}

impl ::protobuf::Clear for ReleaseLockResponse {
    fn clear(&mut self) {
        self.success = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReleaseLockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReleaseLockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLockStatusRequest {
    // message fields
    pub key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLockStatusRequest {
    fn default() -> &'a GetLockStatusRequest {
        <GetLockStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLockStatusRequest {
    pub fn new() -> GetLockStatusRequest {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetLockStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLockStatusRequest {
        GetLockStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &GetLockStatusRequest| { &m.key },
                |m: &mut GetLockStatusRequest| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLockStatusRequest>(
                "GetLockStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLockStatusRequest {
        static instance: ::protobuf::rt::LazyV2<GetLockStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLockStatusRequest::new)
    }
}

impl ::protobuf::Clear for GetLockStatusRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLockStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLockStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLockStatusResponse {
    // message fields
    pub success: bool,
    pub message: ::std::string::String,
    pub lock_status: ::protobuf::SingularPtrField<LockStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLockStatusResponse {
    fn default() -> &'a GetLockStatusResponse {
        <GetLockStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetLockStatusResponse {
    pub fn new() -> GetLockStatusResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // .syros.v1.LockStatus lock_status = 3;


    pub fn get_lock_status(&self) -> &LockStatus {
        self.lock_status.as_ref().unwrap_or_else(|| <LockStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lock_status(&mut self) {
        self.lock_status.clear();
    }

    pub fn has_lock_status(&self) -> bool {
        self.lock_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lock_status(&mut self, v: LockStatus) {
        self.lock_status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lock_status(&mut self) -> &mut LockStatus {
        if self.lock_status.is_none() {
            self.lock_status.set_default();
        }
        self.lock_status.as_mut().unwrap()
    }

    // Take field
    pub fn take_lock_status(&mut self) -> LockStatus {
        self.lock_status.take().unwrap_or_else(|| LockStatus::new())
    }
}

impl ::protobuf::Message for GetLockStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.lock_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lock_status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(ref v) = self.lock_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(ref v) = self.lock_status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLockStatusResponse {
        GetLockStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &GetLockStatusResponse| { &m.success },
                |m: &mut GetLockStatusResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &GetLockStatusResponse| { &m.message },
                |m: &mut GetLockStatusResponse| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LockStatus>>(
                "lock_status",
                |m: &GetLockStatusResponse| { &m.lock_status },
                |m: &mut GetLockStatusResponse| { &mut m.lock_status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetLockStatusResponse>(
                "GetLockStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetLockStatusResponse {
        static instance: ::protobuf::rt::LazyV2<GetLockStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLockStatusResponse::new)
    }
}

impl ::protobuf::Clear for GetLockStatusResponse {
    fn clear(&mut self) {
        self.success = false;
        self.message.clear();
        self.lock_status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLockStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLockStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LockStatus {
    // message fields
    pub id: ::std::string::String,
    pub key: ::std::string::String,
    pub owner: ::std::string::String,
    pub acquired_at: ::std::string::String,
    pub expires_at: ::std::string::String,
    pub metadata: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LockStatus {
    fn default() -> &'a LockStatus {
        <LockStatus as ::protobuf::Message>::default_instance()
    }
}

impl LockStatus {
    pub fn new() -> LockStatus {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string key = 2;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string owner = 3;


    pub fn get_owner(&self) -> &str {
        &self.owner
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        &mut self.owner
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.owner, ::std::string::String::new())
    }

    // string acquired_at = 4;


    pub fn get_acquired_at(&self) -> &str {
        &self.acquired_at
    }
    pub fn clear_acquired_at(&mut self) {
        self.acquired_at.clear();
    }

    // Param is passed by value, moved
    pub fn set_acquired_at(&mut self, v: ::std::string::String) {
        self.acquired_at = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acquired_at(&mut self) -> &mut ::std::string::String {
        &mut self.acquired_at
    }

    // Take field
    pub fn take_acquired_at(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.acquired_at, ::std::string::String::new())
    }

    // string expires_at = 5;


    pub fn get_expires_at(&self) -> &str {
        &self.expires_at
    }
    pub fn clear_expires_at(&mut self) {
        self.expires_at.clear();
    }

    // Param is passed by value, moved
    pub fn set_expires_at(&mut self, v: ::std::string::String) {
        self.expires_at = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expires_at(&mut self) -> &mut ::std::string::String {
        &mut self.expires_at
    }

    // Take field
    pub fn take_expires_at(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.expires_at, ::std::string::String::new())
    }

    // string metadata = 6;


    pub fn get_metadata(&self) -> &str {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::string::String) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.metadata, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LockStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.owner)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.acquired_at)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.expires_at)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key);
        }
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.owner);
        }
        if !self.acquired_at.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.acquired_at);
        }
        if !self.expires_at.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.expires_at);
        }
        if !self.metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.key.is_empty() {
            os.write_string(2, &self.key)?;
        }
        if !self.owner.is_empty() {
            os.write_string(3, &self.owner)?;
        }
        if !self.acquired_at.is_empty() {
            os.write_string(4, &self.acquired_at)?;
        }
        if !self.expires_at.is_empty() {
            os.write_string(5, &self.expires_at)?;
        }
        if !self.metadata.is_empty() {
            os.write_string(6, &self.metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LockStatus {
        LockStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &LockStatus| { &m.id },
                |m: &mut LockStatus| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &LockStatus| { &m.key },
                |m: &mut LockStatus| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "owner",
                |m: &LockStatus| { &m.owner },
                |m: &mut LockStatus| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "acquired_at",
                |m: &LockStatus| { &m.acquired_at },
                |m: &mut LockStatus| { &mut m.acquired_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "expires_at",
                |m: &LockStatus| { &m.expires_at },
                |m: &mut LockStatus| { &mut m.expires_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &LockStatus| { &m.metadata },
                |m: &mut LockStatus| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LockStatus>(
                "LockStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LockStatus {
        static instance: ::protobuf::rt::LazyV2<LockStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LockStatus::new)
    }
}

impl ::protobuf::Clear for LockStatus {
    fn clear(&mut self) {
        self.id.clear();
        self.key.clear();
        self.owner.clear();
        self.acquired_at.clear();
        self.expires_at.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LockStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SagaRequest {
    // message fields
    pub name: ::std::string::String,
    pub steps: ::protobuf::RepeatedField<SagaStep>,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SagaRequest {
    fn default() -> &'a SagaRequest {
        <SagaRequest as ::protobuf::Message>::default_instance()
    }
}

impl SagaRequest {
    pub fn new() -> SagaRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .syros.v1.SagaStep steps = 2;


    pub fn get_steps(&self) -> &[SagaStep] {
        &self.steps
    }
    pub fn clear_steps(&mut self) {
        self.steps.clear();
    }

    // Param is passed by value, moved
    pub fn set_steps(&mut self, v: ::protobuf::RepeatedField<SagaStep>) {
        self.steps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steps(&mut self) -> &mut ::protobuf::RepeatedField<SagaStep> {
        &mut self.steps
    }

    // Take field
    pub fn take_steps(&mut self) -> ::protobuf::RepeatedField<SagaStep> {
        ::std::mem::replace(&mut self.steps, ::protobuf::RepeatedField::new())
    }

    // repeated .syros.v1.SagaRequest.metadata_MapEntry metadata = 3;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for SagaRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.steps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.steps)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.metadata);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.steps {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.metadata, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SagaRequest {
        SagaRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SagaRequest| { &m.name },
                |m: &mut SagaRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SagaStep>>(
                "steps",
                |m: &SagaRequest| { &m.steps },
                |m: &mut SagaRequest| { &mut m.steps },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &SagaRequest| { &m.metadata },
                |m: &mut SagaRequest| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SagaRequest>(
                "SagaRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SagaRequest {
        static instance: ::protobuf::rt::LazyV2<SagaRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SagaRequest::new)
    }
}

impl ::protobuf::Clear for SagaRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.steps.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SagaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SagaRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SagaStep {
    // message fields
    pub name: ::std::string::String,
    pub action: ::std::string::String,
    pub compensation: ::std::string::String,
    pub timeout_seconds: u64,
    pub retry_policy: ::protobuf::SingularPtrField<RetryPolicy>,
    pub payload: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SagaStep {
    fn default() -> &'a SagaStep {
        <SagaStep as ::protobuf::Message>::default_instance()
    }
}

impl SagaStep {
    pub fn new() -> SagaStep {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string action = 2;


    pub fn get_action(&self) -> &str {
        &self.action
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        &mut self.action
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.action, ::std::string::String::new())
    }

    // string compensation = 3;


    pub fn get_compensation(&self) -> &str {
        &self.compensation
    }
    pub fn clear_compensation(&mut self) {
        self.compensation.clear();
    }

    // Param is passed by value, moved
    pub fn set_compensation(&mut self, v: ::std::string::String) {
        self.compensation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compensation(&mut self) -> &mut ::std::string::String {
        &mut self.compensation
    }

    // Take field
    pub fn take_compensation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.compensation, ::std::string::String::new())
    }

    // uint64 timeout_seconds = 4;


    pub fn get_timeout_seconds(&self) -> u64 {
        self.timeout_seconds
    }
    pub fn clear_timeout_seconds(&mut self) {
        self.timeout_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout_seconds(&mut self, v: u64) {
        self.timeout_seconds = v;
    }

    // .syros.v1.RetryPolicy retry_policy = 5;


    pub fn get_retry_policy(&self) -> &RetryPolicy {
        self.retry_policy.as_ref().unwrap_or_else(|| <RetryPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_policy(&mut self) {
        self.retry_policy.clear();
    }

    pub fn has_retry_policy(&self) -> bool {
        self.retry_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_policy(&mut self, v: RetryPolicy) {
        self.retry_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_policy(&mut self) -> &mut RetryPolicy {
        if self.retry_policy.is_none() {
            self.retry_policy.set_default();
        }
        self.retry_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_policy(&mut self) -> RetryPolicy {
        self.retry_policy.take().unwrap_or_else(|| RetryPolicy::new())
    }

    // string payload = 6;


    pub fn get_payload(&self) -> &str {
        &self.payload
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::string::String) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::string::String {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payload, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SagaStep {
    fn is_initialized(&self) -> bool {
        for v in &self.retry_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.action)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.compensation)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timeout_seconds = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_policy)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.action.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.action);
        }
        if !self.compensation.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.compensation);
        }
        if self.timeout_seconds != 0 {
            my_size += ::protobuf::rt::value_size(4, self.timeout_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.action.is_empty() {
            os.write_string(2, &self.action)?;
        }
        if !self.compensation.is_empty() {
            os.write_string(3, &self.compensation)?;
        }
        if self.timeout_seconds != 0 {
            os.write_uint64(4, self.timeout_seconds)?;
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.payload.is_empty() {
            os.write_string(6, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SagaStep {
        SagaStep::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SagaStep| { &m.name },
                |m: &mut SagaStep| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &SagaStep| { &m.action },
                |m: &mut SagaStep| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "compensation",
                |m: &SagaStep| { &m.compensation },
                |m: &mut SagaStep| { &mut m.compensation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "timeout_seconds",
                |m: &SagaStep| { &m.timeout_seconds },
                |m: &mut SagaStep| { &mut m.timeout_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy>>(
                "retry_policy",
                |m: &SagaStep| { &m.retry_policy },
                |m: &mut SagaStep| { &mut m.retry_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payload",
                |m: &SagaStep| { &m.payload },
                |m: &mut SagaStep| { &mut m.payload },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SagaStep>(
                "SagaStep",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SagaStep {
        static instance: ::protobuf::rt::LazyV2<SagaStep> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SagaStep::new)
    }
}

impl ::protobuf::Clear for SagaStep {
    fn clear(&mut self) {
        self.name.clear();
        self.action.clear();
        self.compensation.clear();
        self.timeout_seconds = 0;
        self.retry_policy.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SagaStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SagaStep {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RetryPolicy {
    // message fields
    pub max_retries: u32,
    pub backoff_strategy: ::std::string::String,
    pub initial_delay_seconds: u64,
    pub max_delay_seconds: u64,
    pub factor: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy {
    fn default() -> &'a RetryPolicy {
        <RetryPolicy as ::protobuf::Message>::default_instance()
    }
}

impl RetryPolicy {
    pub fn new() -> RetryPolicy {
        ::std::default::Default::default()
    }

    // uint32 max_retries = 1;


    pub fn get_max_retries(&self) -> u32 {
        self.max_retries
    }
    pub fn clear_max_retries(&mut self) {
        self.max_retries = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_retries(&mut self, v: u32) {
        self.max_retries = v;
    }

    // string backoff_strategy = 2;


    pub fn get_backoff_strategy(&self) -> &str {
        &self.backoff_strategy
    }
    pub fn clear_backoff_strategy(&mut self) {
        self.backoff_strategy.clear();
    }

    // Param is passed by value, moved
    pub fn set_backoff_strategy(&mut self, v: ::std::string::String) {
        self.backoff_strategy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backoff_strategy(&mut self) -> &mut ::std::string::String {
        &mut self.backoff_strategy
    }

    // Take field
    pub fn take_backoff_strategy(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backoff_strategy, ::std::string::String::new())
    }

    // uint64 initial_delay_seconds = 3;


    pub fn get_initial_delay_seconds(&self) -> u64 {
        self.initial_delay_seconds
    }
    pub fn clear_initial_delay_seconds(&mut self) {
        self.initial_delay_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_initial_delay_seconds(&mut self, v: u64) {
        self.initial_delay_seconds = v;
    }

    // uint64 max_delay_seconds = 4;


    pub fn get_max_delay_seconds(&self) -> u64 {
        self.max_delay_seconds
    }
    pub fn clear_max_delay_seconds(&mut self) {
        self.max_delay_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_delay_seconds(&mut self, v: u64) {
        self.max_delay_seconds = v;
    }

    // double factor = 5;


    pub fn get_factor(&self) -> f64 {
        self.factor
    }
    pub fn clear_factor(&mut self) {
        self.factor = 0.;
    }

    // Param is passed by value, moved
    pub fn set_factor(&mut self, v: f64) {
        self.factor = v;
    }
}

impl ::protobuf::Message for RetryPolicy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_retries = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backoff_strategy)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.initial_delay_seconds = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.max_delay_seconds = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.factor = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.max_retries != 0 {
            my_size += ::protobuf::rt::value_size(1, self.max_retries, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.backoff_strategy.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.backoff_strategy);
        }
        if self.initial_delay_seconds != 0 {
            my_size += ::protobuf::rt::value_size(3, self.initial_delay_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_delay_seconds != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_delay_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.factor != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.max_retries != 0 {
            os.write_uint32(1, self.max_retries)?;
        }
        if !self.backoff_strategy.is_empty() {
            os.write_string(2, &self.backoff_strategy)?;
        }
        if self.initial_delay_seconds != 0 {
            os.write_uint64(3, self.initial_delay_seconds)?;
        }
        if self.max_delay_seconds != 0 {
            os.write_uint64(4, self.max_delay_seconds)?;
        }
        if self.factor != 0. {
            os.write_double(5, self.factor)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy {
        RetryPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_retries",
                |m: &RetryPolicy| { &m.max_retries },
                |m: &mut RetryPolicy| { &mut m.max_retries },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backoff_strategy",
                |m: &RetryPolicy| { &m.backoff_strategy },
                |m: &mut RetryPolicy| { &mut m.backoff_strategy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "initial_delay_seconds",
                |m: &RetryPolicy| { &m.initial_delay_seconds },
                |m: &mut RetryPolicy| { &mut m.initial_delay_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "max_delay_seconds",
                |m: &RetryPolicy| { &m.max_delay_seconds },
                |m: &mut RetryPolicy| { &mut m.max_delay_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "factor",
                |m: &RetryPolicy| { &m.factor },
                |m: &mut RetryPolicy| { &mut m.factor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy>(
                "RetryPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy::new)
    }
}

impl ::protobuf::Clear for RetryPolicy {
    fn clear(&mut self) {
        self.max_retries = 0;
        self.backoff_strategy.clear();
        self.initial_delay_seconds = 0;
        self.max_delay_seconds = 0;
        self.factor = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SagaResponse {
    // message fields
    pub saga_id: ::std::string::String,
    pub status: ::std::string::String,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SagaResponse {
    fn default() -> &'a SagaResponse {
        <SagaResponse as ::protobuf::Message>::default_instance()
    }
}

impl SagaResponse {
    pub fn new() -> SagaResponse {
        ::std::default::Default::default()
    }

    // string saga_id = 1;


    pub fn get_saga_id(&self) -> &str {
        &self.saga_id
    }
    pub fn clear_saga_id(&mut self) {
        self.saga_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_saga_id(&mut self, v: ::std::string::String) {
        self.saga_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_saga_id(&mut self) -> &mut ::std::string::String {
        &mut self.saga_id
    }

    // Take field
    pub fn take_saga_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.saga_id, ::std::string::String::new())
    }

    // string status = 2;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SagaResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.saga_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.saga_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.saga_id);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.status);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.saga_id.is_empty() {
            os.write_string(1, &self.saga_id)?;
        }
        if !self.status.is_empty() {
            os.write_string(2, &self.status)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SagaResponse {
        SagaResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "saga_id",
                |m: &SagaResponse| { &m.saga_id },
                |m: &mut SagaResponse| { &mut m.saga_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &SagaResponse| { &m.status },
                |m: &mut SagaResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &SagaResponse| { &m.message },
                |m: &mut SagaResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SagaResponse>(
                "SagaResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SagaResponse {
        static instance: ::protobuf::rt::LazyV2<SagaResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SagaResponse::new)
    }
}

impl ::protobuf::Clear for SagaResponse {
    fn clear(&mut self) {
        self.saga_id.clear();
        self.status.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SagaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SagaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSagaStatusRequest {
    // message fields
    pub saga_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSagaStatusRequest {
    fn default() -> &'a GetSagaStatusRequest {
        <GetSagaStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSagaStatusRequest {
    pub fn new() -> GetSagaStatusRequest {
        ::std::default::Default::default()
    }

    // string saga_id = 1;


    pub fn get_saga_id(&self) -> &str {
        &self.saga_id
    }
    pub fn clear_saga_id(&mut self) {
        self.saga_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_saga_id(&mut self, v: ::std::string::String) {
        self.saga_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_saga_id(&mut self) -> &mut ::std::string::String {
        &mut self.saga_id
    }

    // Take field
    pub fn take_saga_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.saga_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSagaStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.saga_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.saga_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.saga_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.saga_id.is_empty() {
            os.write_string(1, &self.saga_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSagaStatusRequest {
        GetSagaStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "saga_id",
                |m: &GetSagaStatusRequest| { &m.saga_id },
                |m: &mut GetSagaStatusRequest| { &mut m.saga_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSagaStatusRequest>(
                "GetSagaStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSagaStatusRequest {
        static instance: ::protobuf::rt::LazyV2<GetSagaStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSagaStatusRequest::new)
    }
}

impl ::protobuf::Clear for GetSagaStatusRequest {
    fn clear(&mut self) {
        self.saga_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSagaStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSagaStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSagaStatusResponse {
    // message fields
    pub success: bool,
    pub message: ::std::string::String,
    pub saga_status: ::protobuf::SingularPtrField<SagaStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSagaStatusResponse {
    fn default() -> &'a GetSagaStatusResponse {
        <GetSagaStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetSagaStatusResponse {
    pub fn new() -> GetSagaStatusResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // .syros.v1.SagaStatus saga_status = 3;


    pub fn get_saga_status(&self) -> &SagaStatus {
        self.saga_status.as_ref().unwrap_or_else(|| <SagaStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_saga_status(&mut self) {
        self.saga_status.clear();
    }

    pub fn has_saga_status(&self) -> bool {
        self.saga_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_saga_status(&mut self, v: SagaStatus) {
        self.saga_status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_saga_status(&mut self) -> &mut SagaStatus {
        if self.saga_status.is_none() {
            self.saga_status.set_default();
        }
        self.saga_status.as_mut().unwrap()
    }

    // Take field
    pub fn take_saga_status(&mut self) -> SagaStatus {
        self.saga_status.take().unwrap_or_else(|| SagaStatus::new())
    }
}

impl ::protobuf::Message for GetSagaStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.saga_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.saga_status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(ref v) = self.saga_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(ref v) = self.saga_status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSagaStatusResponse {
        GetSagaStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &GetSagaStatusResponse| { &m.success },
                |m: &mut GetSagaStatusResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &GetSagaStatusResponse| { &m.message },
                |m: &mut GetSagaStatusResponse| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SagaStatus>>(
                "saga_status",
                |m: &GetSagaStatusResponse| { &m.saga_status },
                |m: &mut GetSagaStatusResponse| { &mut m.saga_status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetSagaStatusResponse>(
                "GetSagaStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetSagaStatusResponse {
        static instance: ::protobuf::rt::LazyV2<GetSagaStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSagaStatusResponse::new)
    }
}

impl ::protobuf::Clear for GetSagaStatusResponse {
    fn clear(&mut self) {
        self.success = false;
        self.message.clear();
        self.saga_status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSagaStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSagaStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SagaStatus {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub steps: ::protobuf::RepeatedField<SagaStep>,
    pub status: ::std::string::String,
    pub current_step: u32,
    pub created_at: ::std::string::String,
    pub updated_at: ::std::string::String,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SagaStatus {
    fn default() -> &'a SagaStatus {
        <SagaStatus as ::protobuf::Message>::default_instance()
    }
}

impl SagaStatus {
    pub fn new() -> SagaStatus {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .syros.v1.SagaStep steps = 3;


    pub fn get_steps(&self) -> &[SagaStep] {
        &self.steps
    }
    pub fn clear_steps(&mut self) {
        self.steps.clear();
    }

    // Param is passed by value, moved
    pub fn set_steps(&mut self, v: ::protobuf::RepeatedField<SagaStep>) {
        self.steps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steps(&mut self) -> &mut ::protobuf::RepeatedField<SagaStep> {
        &mut self.steps
    }

    // Take field
    pub fn take_steps(&mut self) -> ::protobuf::RepeatedField<SagaStep> {
        ::std::mem::replace(&mut self.steps, ::protobuf::RepeatedField::new())
    }

    // string status = 4;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }

    // uint32 current_step = 5;


    pub fn get_current_step(&self) -> u32 {
        self.current_step
    }
    pub fn clear_current_step(&mut self) {
        self.current_step = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_step(&mut self, v: u32) {
        self.current_step = v;
    }

    // string created_at = 6;


    pub fn get_created_at(&self) -> &str {
        &self.created_at
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::std::string::String) {
        self.created_at = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::std::string::String {
        &mut self.created_at
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.created_at, ::std::string::String::new())
    }

    // string updated_at = 7;


    pub fn get_updated_at(&self) -> &str {
        &self.updated_at
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::std::string::String) {
        self.updated_at = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::std::string::String {
        &mut self.updated_at
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.updated_at, ::std::string::String::new())
    }

    // repeated .syros.v1.SagaStatus.metadata_MapEntry metadata = 8;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for SagaStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.steps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.steps)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.current_step = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.created_at)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.updated_at)?;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.steps {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.status);
        }
        if self.current_step != 0 {
            my_size += ::protobuf::rt::value_size(5, self.current_step, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.created_at.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.created_at);
        }
        if !self.updated_at.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.updated_at);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.metadata);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.steps {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.status.is_empty() {
            os.write_string(4, &self.status)?;
        }
        if self.current_step != 0 {
            os.write_uint32(5, self.current_step)?;
        }
        if !self.created_at.is_empty() {
            os.write_string(6, &self.created_at)?;
        }
        if !self.updated_at.is_empty() {
            os.write_string(7, &self.updated_at)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(8, &self.metadata, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SagaStatus {
        SagaStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &SagaStatus| { &m.id },
                |m: &mut SagaStatus| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SagaStatus| { &m.name },
                |m: &mut SagaStatus| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SagaStep>>(
                "steps",
                |m: &SagaStatus| { &m.steps },
                |m: &mut SagaStatus| { &mut m.steps },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &SagaStatus| { &m.status },
                |m: &mut SagaStatus| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "current_step",
                |m: &SagaStatus| { &m.current_step },
                |m: &mut SagaStatus| { &mut m.current_step },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "created_at",
                |m: &SagaStatus| { &m.created_at },
                |m: &mut SagaStatus| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "updated_at",
                |m: &SagaStatus| { &m.updated_at },
                |m: &mut SagaStatus| { &mut m.updated_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &SagaStatus| { &m.metadata },
                |m: &mut SagaStatus| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SagaStatus>(
                "SagaStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SagaStatus {
        static instance: ::protobuf::rt::LazyV2<SagaStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SagaStatus::new)
    }
}

impl ::protobuf::Clear for SagaStatus {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.steps.clear();
        self.status.clear();
        self.current_step = 0;
        self.created_at.clear();
        self.updated_at.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SagaStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SagaStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventRequest {
    // message fields
    pub stream_id: ::std::string::String,
    pub event_type: ::std::string::String,
    pub data: ::std::string::String,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventRequest {
    fn default() -> &'a EventRequest {
        <EventRequest as ::protobuf::Message>::default_instance()
    }
}

impl EventRequest {
    pub fn new() -> EventRequest {
        ::std::default::Default::default()
    }

    // string stream_id = 1;


    pub fn get_stream_id(&self) -> &str {
        &self.stream_id
    }
    pub fn clear_stream_id(&mut self) {
        self.stream_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_stream_id(&mut self, v: ::std::string::String) {
        self.stream_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_id(&mut self) -> &mut ::std::string::String {
        &mut self.stream_id
    }

    // Take field
    pub fn take_stream_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stream_id, ::std::string::String::new())
    }

    // string event_type = 2;


    pub fn get_event_type(&self) -> &str {
        &self.event_type
    }
    pub fn clear_event_type(&mut self) {
        self.event_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: ::std::string::String) {
        self.event_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_type(&mut self) -> &mut ::std::string::String {
        &mut self.event_type
    }

    // Take field
    pub fn take_event_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.event_type, ::std::string::String::new())
    }

    // string data = 3;


    pub fn get_data(&self) -> &str {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::string::String) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::string::String {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.data, ::std::string::String::new())
    }

    // repeated .syros.v1.EventRequest.metadata_MapEntry metadata = 4;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for EventRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stream_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.event_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.stream_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.stream_id);
        }
        if !self.event_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.event_type);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.data);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.metadata);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.stream_id.is_empty() {
            os.write_string(1, &self.stream_id)?;
        }
        if !self.event_type.is_empty() {
            os.write_string(2, &self.event_type)?;
        }
        if !self.data.is_empty() {
            os.write_string(3, &self.data)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.metadata, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventRequest {
        EventRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stream_id",
                |m: &EventRequest| { &m.stream_id },
                |m: &mut EventRequest| { &mut m.stream_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "event_type",
                |m: &EventRequest| { &m.event_type },
                |m: &mut EventRequest| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "data",
                |m: &EventRequest| { &m.data },
                |m: &mut EventRequest| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &EventRequest| { &m.metadata },
                |m: &mut EventRequest| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventRequest>(
                "EventRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventRequest {
        static instance: ::protobuf::rt::LazyV2<EventRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventRequest::new)
    }
}

impl ::protobuf::Clear for EventRequest {
    fn clear(&mut self) {
        self.stream_id.clear();
        self.event_type.clear();
        self.data.clear();
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventResponse {
    // message fields
    pub event_id: ::std::string::String,
    pub version: u64,
    pub success: bool,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventResponse {
    fn default() -> &'a EventResponse {
        <EventResponse as ::protobuf::Message>::default_instance()
    }
}

impl EventResponse {
    pub fn new() -> EventResponse {
        ::std::default::Default::default()
    }

    // string event_id = 1;


    pub fn get_event_id(&self) -> &str {
        &self.event_id
    }
    pub fn clear_event_id(&mut self) {
        self.event_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: ::std::string::String) {
        self.event_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_id(&mut self) -> &mut ::std::string::String {
        &mut self.event_id
    }

    // Take field
    pub fn take_event_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.event_id, ::std::string::String::new())
    }

    // uint64 version = 2;


    pub fn get_version(&self) -> u64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = v;
    }

    // bool success = 3;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string message = 4;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EventResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.event_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.event_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.event_id);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.success != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.event_id.is_empty() {
            os.write_string(1, &self.event_id)?;
        }
        if self.version != 0 {
            os.write_uint64(2, self.version)?;
        }
        if self.success != false {
            os.write_bool(3, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(4, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventResponse {
        EventResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "event_id",
                |m: &EventResponse| { &m.event_id },
                |m: &mut EventResponse| { &mut m.event_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "version",
                |m: &EventResponse| { &m.version },
                |m: &mut EventResponse| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &EventResponse| { &m.success },
                |m: &mut EventResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &EventResponse| { &m.message },
                |m: &mut EventResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventResponse>(
                "EventResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventResponse {
        static instance: ::protobuf::rt::LazyV2<EventResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventResponse::new)
    }
}

impl ::protobuf::Clear for EventResponse {
    fn clear(&mut self) {
        self.event_id.clear();
        self.version = 0;
        self.success = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEventsRequest {
    // message fields
    pub stream_id: ::std::string::String,
    pub from_version: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEventsRequest {
    fn default() -> &'a GetEventsRequest {
        <GetEventsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetEventsRequest {
    pub fn new() -> GetEventsRequest {
        ::std::default::Default::default()
    }

    // string stream_id = 1;


    pub fn get_stream_id(&self) -> &str {
        &self.stream_id
    }
    pub fn clear_stream_id(&mut self) {
        self.stream_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_stream_id(&mut self, v: ::std::string::String) {
        self.stream_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_id(&mut self) -> &mut ::std::string::String {
        &mut self.stream_id
    }

    // Take field
    pub fn take_stream_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stream_id, ::std::string::String::new())
    }

    // uint64 from_version = 2;


    pub fn get_from_version(&self) -> u64 {
        self.from_version
    }
    pub fn clear_from_version(&mut self) {
        self.from_version = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_version(&mut self, v: u64) {
        self.from_version = v;
    }
}

impl ::protobuf::Message for GetEventsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stream_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.from_version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.stream_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.stream_id);
        }
        if self.from_version != 0 {
            my_size += ::protobuf::rt::value_size(2, self.from_version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.stream_id.is_empty() {
            os.write_string(1, &self.stream_id)?;
        }
        if self.from_version != 0 {
            os.write_uint64(2, self.from_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEventsRequest {
        GetEventsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stream_id",
                |m: &GetEventsRequest| { &m.stream_id },
                |m: &mut GetEventsRequest| { &mut m.stream_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "from_version",
                |m: &GetEventsRequest| { &m.from_version },
                |m: &mut GetEventsRequest| { &mut m.from_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEventsRequest>(
                "GetEventsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEventsRequest {
        static instance: ::protobuf::rt::LazyV2<GetEventsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEventsRequest::new)
    }
}

impl ::protobuf::Clear for GetEventsRequest {
    fn clear(&mut self) {
        self.stream_id.clear();
        self.from_version = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEventsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEventsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEventsResponse {
    // message fields
    pub events: ::protobuf::RepeatedField<Event>,
    pub success: bool,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEventsResponse {
    fn default() -> &'a GetEventsResponse {
        <GetEventsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetEventsResponse {
    pub fn new() -> GetEventsResponse {
        ::std::default::Default::default()
    }

    // repeated .syros.v1.Event events = 1;


    pub fn get_events(&self) -> &[Event] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<Event>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<Event> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<Event> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // bool success = 2;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetEventsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.success != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.events {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEventsResponse {
        GetEventsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Event>>(
                "events",
                |m: &GetEventsResponse| { &m.events },
                |m: &mut GetEventsResponse| { &mut m.events },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &GetEventsResponse| { &m.success },
                |m: &mut GetEventsResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &GetEventsResponse| { &m.message },
                |m: &mut GetEventsResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEventsResponse>(
                "GetEventsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEventsResponse {
        static instance: ::protobuf::rt::LazyV2<GetEventsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEventsResponse::new)
    }
}

impl ::protobuf::Clear for GetEventsResponse {
    fn clear(&mut self) {
        self.events.clear();
        self.success = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEventsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEventsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Event {
    // message fields
    pub id: ::std::string::String,
    pub stream_id: ::std::string::String,
    pub event_type: ::std::string::String,
    pub data: ::std::string::String,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub timestamp: ::std::string::String,
    pub version: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string stream_id = 2;


    pub fn get_stream_id(&self) -> &str {
        &self.stream_id
    }
    pub fn clear_stream_id(&mut self) {
        self.stream_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_stream_id(&mut self, v: ::std::string::String) {
        self.stream_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_id(&mut self) -> &mut ::std::string::String {
        &mut self.stream_id
    }

    // Take field
    pub fn take_stream_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stream_id, ::std::string::String::new())
    }

    // string event_type = 3;


    pub fn get_event_type(&self) -> &str {
        &self.event_type
    }
    pub fn clear_event_type(&mut self) {
        self.event_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: ::std::string::String) {
        self.event_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_type(&mut self) -> &mut ::std::string::String {
        &mut self.event_type
    }

    // Take field
    pub fn take_event_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.event_type, ::std::string::String::new())
    }

    // string data = 4;


    pub fn get_data(&self) -> &str {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::string::String) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::string::String {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.data, ::std::string::String::new())
    }

    // repeated .syros.v1.Event.metadata_MapEntry metadata = 5;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }

    // string timestamp = 6;


    pub fn get_timestamp(&self) -> &str {
        &self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::std::string::String) {
        self.timestamp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp(&mut self) -> &mut ::std::string::String {
        &mut self.timestamp
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.timestamp, ::std::string::String::new())
    }

    // uint64 version = 7;


    pub fn get_version(&self) -> u64 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = v;
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stream_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.event_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.timestamp)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.stream_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.stream_id);
        }
        if !self.event_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.event_type);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.data);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.metadata);
        if !self.timestamp.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.timestamp);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(7, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.stream_id.is_empty() {
            os.write_string(2, &self.stream_id)?;
        }
        if !self.event_type.is_empty() {
            os.write_string(3, &self.event_type)?;
        }
        if !self.data.is_empty() {
            os.write_string(4, &self.data)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.metadata, os)?;
        if !self.timestamp.is_empty() {
            os.write_string(6, &self.timestamp)?;
        }
        if self.version != 0 {
            os.write_uint64(7, self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Event {
        Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Event| { &m.id },
                |m: &mut Event| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stream_id",
                |m: &Event| { &m.stream_id },
                |m: &mut Event| { &mut m.stream_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "event_type",
                |m: &Event| { &m.event_type },
                |m: &mut Event| { &mut m.event_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "data",
                |m: &Event| { &m.data },
                |m: &mut Event| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &Event| { &m.metadata },
                |m: &mut Event| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "timestamp",
                |m: &Event| { &m.timestamp },
                |m: &mut Event| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "version",
                |m: &Event| { &m.version },
                |m: &mut Event| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Event>(
                "Event",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Event {
        static instance: ::protobuf::rt::LazyV2<Event> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Event::new)
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.id.clear();
        self.stream_id.clear();
        self.event_type.clear();
        self.data.clear();
        self.metadata.clear();
        self.timestamp.clear();
        self.version = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCacheRequest {
    // message fields
    pub key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCacheRequest {
    fn default() -> &'a GetCacheRequest {
        <GetCacheRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCacheRequest {
    pub fn new() -> GetCacheRequest {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetCacheRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCacheRequest {
        GetCacheRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &GetCacheRequest| { &m.key },
                |m: &mut GetCacheRequest| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCacheRequest>(
                "GetCacheRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCacheRequest {
        static instance: ::protobuf::rt::LazyV2<GetCacheRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCacheRequest::new)
    }
}

impl ::protobuf::Clear for GetCacheRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCacheRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCacheRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCacheResponse {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    pub expires_at: ::std::string::String,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    pub success: bool,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCacheResponse {
    fn default() -> &'a GetCacheResponse {
        <GetCacheResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetCacheResponse {
    pub fn new() -> GetCacheResponse {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // string expires_at = 3;


    pub fn get_expires_at(&self) -> &str {
        &self.expires_at
    }
    pub fn clear_expires_at(&mut self) {
        self.expires_at.clear();
    }

    // Param is passed by value, moved
    pub fn set_expires_at(&mut self, v: ::std::string::String) {
        self.expires_at = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expires_at(&mut self) -> &mut ::std::string::String {
        &mut self.expires_at
    }

    // Take field
    pub fn take_expires_at(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.expires_at, ::std::string::String::new())
    }

    // repeated string tags = 4;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // bool success = 5;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string message = 6;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetCacheResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.expires_at)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        if !self.expires_at.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.expires_at);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.success != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        if !self.expires_at.is_empty() {
            os.write_string(3, &self.expires_at)?;
        }
        for v in &self.tags {
            os.write_string(4, &v)?;
        };
        if self.success != false {
            os.write_bool(5, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(6, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCacheResponse {
        GetCacheResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &GetCacheResponse| { &m.key },
                |m: &mut GetCacheResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &GetCacheResponse| { &m.value },
                |m: &mut GetCacheResponse| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "expires_at",
                |m: &GetCacheResponse| { &m.expires_at },
                |m: &mut GetCacheResponse| { &mut m.expires_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &GetCacheResponse| { &m.tags },
                |m: &mut GetCacheResponse| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &GetCacheResponse| { &m.success },
                |m: &mut GetCacheResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &GetCacheResponse| { &m.message },
                |m: &mut GetCacheResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCacheResponse>(
                "GetCacheResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCacheResponse {
        static instance: ::protobuf::rt::LazyV2<GetCacheResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCacheResponse::new)
    }
}

impl ::protobuf::Clear for GetCacheResponse {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.expires_at.clear();
        self.tags.clear();
        self.success = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCacheResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCacheResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetCacheRequest {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    pub ttl_seconds: u64,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetCacheRequest {
    fn default() -> &'a SetCacheRequest {
        <SetCacheRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetCacheRequest {
    pub fn new() -> SetCacheRequest {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // uint64 ttl_seconds = 3;


    pub fn get_ttl_seconds(&self) -> u64 {
        self.ttl_seconds
    }
    pub fn clear_ttl_seconds(&mut self) {
        self.ttl_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_ttl_seconds(&mut self, v: u64) {
        self.ttl_seconds = v;
    }

    // repeated string tags = 4;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SetCacheRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ttl_seconds = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        if self.ttl_seconds != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ttl_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        if self.ttl_seconds != 0 {
            os.write_uint64(3, self.ttl_seconds)?;
        }
        for v in &self.tags {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetCacheRequest {
        SetCacheRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &SetCacheRequest| { &m.key },
                |m: &mut SetCacheRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &SetCacheRequest| { &m.value },
                |m: &mut SetCacheRequest| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ttl_seconds",
                |m: &SetCacheRequest| { &m.ttl_seconds },
                |m: &mut SetCacheRequest| { &mut m.ttl_seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &SetCacheRequest| { &m.tags },
                |m: &mut SetCacheRequest| { &mut m.tags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetCacheRequest>(
                "SetCacheRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetCacheRequest {
        static instance: ::protobuf::rt::LazyV2<SetCacheRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetCacheRequest::new)
    }
}

impl ::protobuf::Clear for SetCacheRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.ttl_seconds = 0;
        self.tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetCacheRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetCacheRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetCacheResponse {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    pub expires_at: ::std::string::String,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    pub success: bool,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetCacheResponse {
    fn default() -> &'a SetCacheResponse {
        <SetCacheResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetCacheResponse {
    pub fn new() -> SetCacheResponse {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // string expires_at = 3;


    pub fn get_expires_at(&self) -> &str {
        &self.expires_at
    }
    pub fn clear_expires_at(&mut self) {
        self.expires_at.clear();
    }

    // Param is passed by value, moved
    pub fn set_expires_at(&mut self, v: ::std::string::String) {
        self.expires_at = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expires_at(&mut self) -> &mut ::std::string::String {
        &mut self.expires_at
    }

    // Take field
    pub fn take_expires_at(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.expires_at, ::std::string::String::new())
    }

    // repeated string tags = 4;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // bool success = 5;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string message = 6;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetCacheResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.expires_at)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        if !self.expires_at.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.expires_at);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.success != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        if !self.expires_at.is_empty() {
            os.write_string(3, &self.expires_at)?;
        }
        for v in &self.tags {
            os.write_string(4, &v)?;
        };
        if self.success != false {
            os.write_bool(5, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(6, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetCacheResponse {
        SetCacheResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &SetCacheResponse| { &m.key },
                |m: &mut SetCacheResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &SetCacheResponse| { &m.value },
                |m: &mut SetCacheResponse| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "expires_at",
                |m: &SetCacheResponse| { &m.expires_at },
                |m: &mut SetCacheResponse| { &mut m.expires_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &SetCacheResponse| { &m.tags },
                |m: &mut SetCacheResponse| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &SetCacheResponse| { &m.success },
                |m: &mut SetCacheResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &SetCacheResponse| { &m.message },
                |m: &mut SetCacheResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetCacheResponse>(
                "SetCacheResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetCacheResponse {
        static instance: ::protobuf::rt::LazyV2<SetCacheResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetCacheResponse::new)
    }
}

impl ::protobuf::Clear for SetCacheResponse {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.expires_at.clear();
        self.tags.clear();
        self.success = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetCacheResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetCacheResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteCacheRequest {
    // message fields
    pub key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteCacheRequest {
    fn default() -> &'a DeleteCacheRequest {
        <DeleteCacheRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCacheRequest {
    pub fn new() -> DeleteCacheRequest {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteCacheRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteCacheRequest {
        DeleteCacheRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &DeleteCacheRequest| { &m.key },
                |m: &mut DeleteCacheRequest| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteCacheRequest>(
                "DeleteCacheRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteCacheRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteCacheRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteCacheRequest::new)
    }
}

impl ::protobuf::Clear for DeleteCacheRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteCacheRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCacheRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteCacheResponse {
    // message fields
    pub success: bool,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteCacheResponse {
    fn default() -> &'a DeleteCacheResponse {
        <DeleteCacheResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCacheResponse {
    pub fn new() -> DeleteCacheResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteCacheResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteCacheResponse {
        DeleteCacheResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &DeleteCacheResponse| { &m.success },
                |m: &mut DeleteCacheResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &DeleteCacheResponse| { &m.message },
                |m: &mut DeleteCacheResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteCacheResponse>(
                "DeleteCacheResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteCacheResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteCacheResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteCacheResponse::new)
    }
}

impl ::protobuf::Clear for DeleteCacheResponse {
    fn clear(&mut self) {
        self.success = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteCacheResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCacheResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InvalidateCacheByTagRequest {
    // message fields
    pub tag: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InvalidateCacheByTagRequest {
    fn default() -> &'a InvalidateCacheByTagRequest {
        <InvalidateCacheByTagRequest as ::protobuf::Message>::default_instance()
    }
}

impl InvalidateCacheByTagRequest {
    pub fn new() -> InvalidateCacheByTagRequest {
        ::std::default::Default::default()
    }

    // string tag = 1;


    pub fn get_tag(&self) -> &str {
        &self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tag, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InvalidateCacheByTagRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.tag.is_empty() {
            os.write_string(1, &self.tag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvalidateCacheByTagRequest {
        InvalidateCacheByTagRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag",
                |m: &InvalidateCacheByTagRequest| { &m.tag },
                |m: &mut InvalidateCacheByTagRequest| { &mut m.tag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InvalidateCacheByTagRequest>(
                "InvalidateCacheByTagRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InvalidateCacheByTagRequest {
        static instance: ::protobuf::rt::LazyV2<InvalidateCacheByTagRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InvalidateCacheByTagRequest::new)
    }
}

impl ::protobuf::Clear for InvalidateCacheByTagRequest {
    fn clear(&mut self) {
        self.tag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvalidateCacheByTagRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvalidateCacheByTagRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InvalidateCacheByTagResponse {
    // message fields
    pub invalidated_count: u64,
    pub success: bool,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InvalidateCacheByTagResponse {
    fn default() -> &'a InvalidateCacheByTagResponse {
        <InvalidateCacheByTagResponse as ::protobuf::Message>::default_instance()
    }
}

impl InvalidateCacheByTagResponse {
    pub fn new() -> InvalidateCacheByTagResponse {
        ::std::default::Default::default()
    }

    // uint64 invalidated_count = 1;


    pub fn get_invalidated_count(&self) -> u64 {
        self.invalidated_count
    }
    pub fn clear_invalidated_count(&mut self) {
        self.invalidated_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_invalidated_count(&mut self, v: u64) {
        self.invalidated_count = v;
    }

    // bool success = 2;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InvalidateCacheByTagResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.invalidated_count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.invalidated_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.invalidated_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.success != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.invalidated_count != 0 {
            os.write_uint64(1, self.invalidated_count)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvalidateCacheByTagResponse {
        InvalidateCacheByTagResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "invalidated_count",
                |m: &InvalidateCacheByTagResponse| { &m.invalidated_count },
                |m: &mut InvalidateCacheByTagResponse| { &mut m.invalidated_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &InvalidateCacheByTagResponse| { &m.success },
                |m: &mut InvalidateCacheByTagResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &InvalidateCacheByTagResponse| { &m.message },
                |m: &mut InvalidateCacheByTagResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InvalidateCacheByTagResponse>(
                "InvalidateCacheByTagResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InvalidateCacheByTagResponse {
        static instance: ::protobuf::rt::LazyV2<InvalidateCacheByTagResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InvalidateCacheByTagResponse::new)
    }
}

impl ::protobuf::Clear for InvalidateCacheByTagResponse {
    fn clear(&mut self) {
        self.invalidated_count = 0;
        self.success = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvalidateCacheByTagResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvalidateCacheByTagResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCacheStatsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCacheStatsRequest {
    fn default() -> &'a GetCacheStatsRequest {
        <GetCacheStatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCacheStatsRequest {
    pub fn new() -> GetCacheStatsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCacheStatsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCacheStatsRequest {
        GetCacheStatsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCacheStatsRequest>(
                "GetCacheStatsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCacheStatsRequest {
        static instance: ::protobuf::rt::LazyV2<GetCacheStatsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCacheStatsRequest::new)
    }
}

impl ::protobuf::Clear for GetCacheStatsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCacheStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCacheStatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCacheStatsResponse {
    // message fields
    pub stats: ::std::collections::HashMap<::std::string::String, u64>,
    pub success: bool,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCacheStatsResponse {
    fn default() -> &'a GetCacheStatsResponse {
        <GetCacheStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetCacheStatsResponse {
    pub fn new() -> GetCacheStatsResponse {
        ::std::default::Default::default()
    }

    // repeated .syros.v1.GetCacheStatsResponse.stats_MapEntry stats = 1;


    pub fn get_stats(&self) -> &::std::collections::HashMap<::std::string::String, u64> {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::std::collections::HashMap<::std::string::String, u64>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u64> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::std::collections::HashMap<::std::string::String, u64> {
        ::std::mem::replace(&mut self.stats, ::std::collections::HashMap::new())
    }

    // bool success = 2;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetCacheStatsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(wire_type, is, &mut self.stats)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(1, &self.stats);
        if self.success != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(1, &self.stats, os)?;
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCacheStatsResponse {
        GetCacheStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeUint64>(
                "stats",
                |m: &GetCacheStatsResponse| { &m.stats },
                |m: &mut GetCacheStatsResponse| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "success",
                |m: &GetCacheStatsResponse| { &m.success },
                |m: &mut GetCacheStatsResponse| { &mut m.success },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &GetCacheStatsResponse| { &m.message },
                |m: &mut GetCacheStatsResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCacheStatsResponse>(
                "GetCacheStatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCacheStatsResponse {
        static instance: ::protobuf::rt::LazyV2<GetCacheStatsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCacheStatsResponse::new)
    }
}

impl ::protobuf::Clear for GetCacheStatsResponse {
    fn clear(&mut self) {
        self.stats.clear();
        self.success = false;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCacheStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCacheStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bsyros.proto\x12\x08syros.v1\"\xb0\x01\n\x0bLockRequest\x12\x12\n\
    \x03key\x18\x01\x20\x01(\tR\x03keyB\0\x12\x16\n\x05owner\x18\x02\x20\x01\
    (\tR\x05ownerB\0\x12!\n\x0bttl_seconds\x18\x03\x20\x01(\x04R\nttlSeconds\
    B\0\x12\x1c\n\x08metadata\x18\x04\x20\x01(\tR\x08metadataB\0\x122\n\x14w\
    ait_timeout_seconds\x18\x05\x20\x01(\x04R\x12waitTimeoutSecondsB\0:\0\"c\
    \n\x0cLockResponse\x12\x19\n\x07lock_id\x18\x01\x20\x01(\tR\x06lockIdB\0\
    \x12\x1a\n\x07success\x18\x02\x20\x01(\x08R\x07successB\0\x12\x1a\n\x07m\
    essage\x18\x03\x20\x01(\tR\x07messageB\0:\0\"*\n\x12ReleaseLockRequest\
    \x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\0:\0\"O\n\x13ReleaseLockRe\
    sponse\x12\x1a\n\x07success\x18\x01\x20\x01(\x08R\x07successB\0\x12\x1a\
    \n\x07message\x18\x02\x20\x01(\tR\x07messageB\0:\0\",\n\x14GetLockStatus\
    Request\x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\0:\0\"\x8a\x01\n\
    \x15GetLockStatusResponse\x12\x1a\n\x07success\x18\x01\x20\x01(\x08R\x07\
    successB\0\x12\x1a\n\x07message\x18\x02\x20\x01(\tR\x07messageB\0\x127\n\
    \x0block_status\x18\x03\x20\x01(\x0b2\x14.syros.v1.LockStatusR\nlockStat\
    usB\0:\0\"\xae\x01\n\nLockStatus\x12\x10\n\x02id\x18\x01\x20\x01(\tR\x02\
    idB\0\x12\x12\n\x03key\x18\x02\x20\x01(\tR\x03keyB\0\x12\x16\n\x05owner\
    \x18\x03\x20\x01(\tR\x05ownerB\0\x12!\n\x0bacquired_at\x18\x04\x20\x01(\
    \tR\nacquiredAtB\0\x12\x1f\n\nexpires_at\x18\x05\x20\x01(\tR\texpiresAtB\
    \0\x12\x1c\n\x08metadata\x18\x06\x20\x01(\tR\x08metadataB\0:\0\"\xd5\x01\
    \n\x0bSagaRequest\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12*\
    \n\x05steps\x18\x02\x20\x03(\x0b2\x12.syros.v1.SagaStepR\x05stepsB\0\x12\
    E\n\x08metadata\x18\x03\x20\x03(\x0b2'.syros.v1.SagaRequest.metadata_Map\
    EntryR\x08metadataB\0\x1a;\n\x11metadata_MapEntry\x12\x0e\n\x03key\x18\
    \x01(\tR\x03key\x12\x12\n\x05value\x18\x02(\tR\x05value:\x028\x01:\0\"\
    \xe5\x01\n\x08SagaStep\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\
    \x12\x18\n\x06action\x18\x02\x20\x01(\tR\x06actionB\0\x12$\n\x0ccompensa\
    tion\x18\x03\x20\x01(\tR\x0ccompensationB\0\x12)\n\x0ftimeout_seconds\
    \x18\x04\x20\x01(\x04R\x0etimeoutSecondsB\0\x12:\n\x0cretry_policy\x18\
    \x05\x20\x01(\x0b2\x15.syros.v1.RetryPolicyR\x0bretryPolicyB\0\x12\x1a\n\
    \x07payload\x18\x06\x20\x01(\tR\x07payloadB\0:\0\"\xdd\x01\n\x0bRetryPol\
    icy\x12!\n\x0bmax_retries\x18\x01\x20\x01(\rR\nmaxRetriesB\0\x12+\n\x10b\
    ackoff_strategy\x18\x02\x20\x01(\tR\x0fbackoffStrategyB\0\x124\n\x15init\
    ial_delay_seconds\x18\x03\x20\x01(\x04R\x13initialDelaySecondsB\0\x12,\n\
    \x11max_delay_seconds\x18\x04\x20\x01(\x04R\x0fmaxDelaySecondsB\0\x12\
    \x18\n\x06factor\x18\x05\x20\x01(\x01R\x06factorB\0:\0\"a\n\x0cSagaRespo\
    nse\x12\x19\n\x07saga_id\x18\x01\x20\x01(\tR\x06sagaIdB\0\x12\x18\n\x06s\
    tatus\x18\x02\x20\x01(\tR\x06statusB\0\x12\x1a\n\x07message\x18\x03\x20\
    \x01(\tR\x07messageB\0:\0\"3\n\x14GetSagaStatusRequest\x12\x19\n\x07saga\
    _id\x18\x01\x20\x01(\tR\x06sagaIdB\0:\0\"\x8a\x01\n\x15GetSagaStatusResp\
    onse\x12\x1a\n\x07success\x18\x01\x20\x01(\x08R\x07successB\0\x12\x1a\n\
    \x07message\x18\x02\x20\x01(\tR\x07messageB\0\x127\n\x0bsaga_status\x18\
    \x03\x20\x01(\x0b2\x14.syros.v1.SagaStatusR\nsagaStatusB\0:\0\"\xe6\x02\
    \n\nSagaStatus\x12\x10\n\x02id\x18\x01\x20\x01(\tR\x02idB\0\x12\x14\n\
    \x04name\x18\x02\x20\x01(\tR\x04nameB\0\x12*\n\x05steps\x18\x03\x20\x03(\
    \x0b2\x12.syros.v1.SagaStepR\x05stepsB\0\x12\x18\n\x06status\x18\x04\x20\
    \x01(\tR\x06statusB\0\x12#\n\x0ccurrent_step\x18\x05\x20\x01(\rR\x0bcurr\
    entStepB\0\x12\x1f\n\ncreated_at\x18\x06\x20\x01(\tR\tcreatedAtB\0\x12\
    \x1f\n\nupdated_at\x18\x07\x20\x01(\tR\tupdatedAtB\0\x12D\n\x08metadata\
    \x18\x08\x20\x03(\x0b2&.syros.v1.SagaStatus.metadata_MapEntryR\x08metada\
    taB\0\x1a;\n\x11metadata_MapEntry\x12\x0e\n\x03key\x18\x01(\tR\x03key\
    \x12\x12\n\x05value\x18\x02(\tR\x05value:\x028\x01:\0\"\xeb\x01\n\x0cEve\
    ntRequest\x12\x1d\n\tstream_id\x18\x01\x20\x01(\tR\x08streamIdB\0\x12\
    \x1f\n\nevent_type\x18\x02\x20\x01(\tR\teventTypeB\0\x12\x14\n\x04data\
    \x18\x03\x20\x01(\tR\x04dataB\0\x12F\n\x08metadata\x18\x04\x20\x03(\x0b2\
    (.syros.v1.EventRequest.metadata_MapEntryR\x08metadataB\0\x1a;\n\x11meta\
    data_MapEntry\x12\x0e\n\x03key\x18\x01(\tR\x03key\x12\x12\n\x05value\x18\
    \x02(\tR\x05value:\x028\x01:\0\"\x82\x01\n\rEventResponse\x12\x1b\n\x08e\
    vent_id\x18\x01\x20\x01(\tR\x07eventIdB\0\x12\x1a\n\x07version\x18\x02\
    \x20\x01(\x04R\x07versionB\0\x12\x1a\n\x07success\x18\x03\x20\x01(\x08R\
    \x07successB\0\x12\x1a\n\x07message\x18\x04\x20\x01(\tR\x07messageB\0:\0\
    \"X\n\x10GetEventsRequest\x12\x1d\n\tstream_id\x18\x01\x20\x01(\tR\x08st\
    reamIdB\0\x12#\n\x0cfrom_version\x18\x02\x20\x01(\x04R\x0bfromVersionB\0\
    :\0\"x\n\x11GetEventsResponse\x12)\n\x06events\x18\x01\x20\x03(\x0b2\x0f\
    .syros.v1.EventR\x06eventsB\0\x12\x1a\n\x07success\x18\x02\x20\x01(\x08R\
    \x07successB\0\x12\x1a\n\x07message\x18\x03\x20\x01(\tR\x07messageB\0:\0\
    \"\xab\x02\n\x05Event\x12\x10\n\x02id\x18\x01\x20\x01(\tR\x02idB\0\x12\
    \x1d\n\tstream_id\x18\x02\x20\x01(\tR\x08streamIdB\0\x12\x1f\n\nevent_ty\
    pe\x18\x03\x20\x01(\tR\teventTypeB\0\x12\x14\n\x04data\x18\x04\x20\x01(\
    \tR\x04dataB\0\x12?\n\x08metadata\x18\x05\x20\x03(\x0b2!.syros.v1.Event.\
    metadata_MapEntryR\x08metadataB\0\x12\x1e\n\ttimestamp\x18\x06\x20\x01(\
    \tR\ttimestampB\0\x12\x1a\n\x07version\x18\x07\x20\x01(\x04R\x07versionB\
    \0\x1a;\n\x11metadata_MapEntry\x12\x0e\n\x03key\x18\x01(\tR\x03key\x12\
    \x12\n\x05value\x18\x02(\tR\x05value:\x028\x01:\0\"'\n\x0fGetCacheReques\
    t\x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\0:\0\"\xaf\x01\n\x10GetCa\
    cheResponse\x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\0\x12\x16\n\x05\
    value\x18\x02\x20\x01(\tR\x05valueB\0\x12\x1f\n\nexpires_at\x18\x03\x20\
    \x01(\tR\texpiresAtB\0\x12\x14\n\x04tags\x18\x04\x20\x03(\tR\x04tagsB\0\
    \x12\x1a\n\x07success\x18\x05\x20\x01(\x08R\x07successB\0\x12\x1a\n\x07m\
    essage\x18\x06\x20\x01(\tR\x07messageB\0:\0\"x\n\x0fSetCacheRequest\x12\
    \x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\0\x12\x16\n\x05value\x18\x02\
    \x20\x01(\tR\x05valueB\0\x12!\n\x0bttl_seconds\x18\x03\x20\x01(\x04R\ntt\
    lSecondsB\0\x12\x14\n\x04tags\x18\x04\x20\x03(\tR\x04tagsB\0:\0\"\xaf\
    \x01\n\x10SetCacheResponse\x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\
    \0\x12\x16\n\x05value\x18\x02\x20\x01(\tR\x05valueB\0\x12\x1f\n\nexpires\
    _at\x18\x03\x20\x01(\tR\texpiresAtB\0\x12\x14\n\x04tags\x18\x04\x20\x03(\
    \tR\x04tagsB\0\x12\x1a\n\x07success\x18\x05\x20\x01(\x08R\x07successB\0\
    \x12\x1a\n\x07message\x18\x06\x20\x01(\tR\x07messageB\0:\0\"*\n\x12Delet\
    eCacheRequest\x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\0:\0\"O\n\x13\
    DeleteCacheResponse\x12\x1a\n\x07success\x18\x01\x20\x01(\x08R\x07succes\
    sB\0\x12\x1a\n\x07message\x18\x02\x20\x01(\tR\x07messageB\0:\0\"3\n\x1bI\
    nvalidateCacheByTagRequest\x12\x12\n\x03tag\x18\x01\x20\x01(\tR\x03tagB\
    \0:\0\"\x87\x01\n\x1cInvalidateCacheByTagResponse\x12-\n\x11invalidated_\
    count\x18\x01\x20\x01(\x04R\x10invalidatedCountB\0\x12\x1a\n\x07success\
    \x18\x02\x20\x01(\x08R\x07successB\0\x12\x1a\n\x07message\x18\x03\x20\
    \x01(\tR\x07messageB\0:\0\"\x18\n\x14GetCacheStatsRequest:\0\"\xd3\x01\n\
    \x15GetCacheStatsResponse\x12F\n\x05stats\x18\x01\x20\x03(\x0b2..syros.v\
    1.GetCacheStatsResponse.stats_MapEntryR\x05statsB\0\x12\x1a\n\x07success\
    \x18\x02\x20\x01(\x08R\x07successB\0\x12\x1a\n\x07message\x18\x03\x20\
    \x01(\tR\x07messageB\0\x1a8\n\x0estats_MapEntry\x12\x0e\n\x03key\x18\x01\
    (\tR\x03key\x12\x12\n\x05value\x18\x02(\x04R\x05value:\x028\x01:\0B\0b\
    \x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
